[{"content":"BOJ 2470 두 용액 link\n문제 요약하면 주어진 배열에서 두 수를 더했을 때 0에 가장 가까운 두 수를 구하는 것이다.\n풀이 Two pointers 알고리즘을 알고 있다면, 쉽게 풀 수 있다.\n풀이는 다음과 같다.\nleft가 배열의 처음 / right가 배열의 마지막을 가르치고 있다.\n 우선 들어온 용액을 오름차순 정렬한다. left가 가리키는 수와 right가 가리키는 수를 더한다.\n2-1. 더한 결과가 현재 0과 가까운 수보다 더 0에 가까우면 업데이트한다. 결과가 0이라면 그대로 종료해도 된다.\n2-2. 더한 결과가 0보다 작다면 left를 +1 해준다. 이후 다시 2번부터 진행한다. 2-3. 더한 결과가 0보다 크다면 right를 -1 해준다. 이후 다시 2번부터 진행한다.  반복하다가 left \u0026lt; right 를 만족하지 못하면 종료한다.\n두 수의 합에 따라 용액을 더 넣거나 빼는 것으로 생각하면 쉽다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  /** * @file 2470.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief two pointers * @version 0.1 * @date 2022-04-11 20:53 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  void solve(int n, vector\u0026lt;int\u0026gt; \u0026amp;water) { pair\u0026lt;int, int\u0026gt; ans; int left = 0, right = n - 1; ans.first = ans.second = 1e9; while (left \u0026lt; right) { if (abs(water[left] + water[right]) \u0026lt;= abs(ans.first + ans.second)) { ans.first = water[left]; ans.second = water[right]; if (ans.first + ans.second == 0) break; } if (water[left] + water[right] \u0026lt; 0) left++; else right--; } cout \u0026lt;\u0026lt; ans.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans.second \u0026lt;\u0026lt; endl; } int main(void) { fastio; int n; vector\u0026lt;int\u0026gt; water; cin \u0026gt;\u0026gt; n; water.resize(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; water[i]; sort(water.begin(), water.end()); solve(n, water); return 0; }   ","date":"2022-04-11T21:06:22+09:00","image":"https://kadrick.github.io/Blog/p/boj-2470/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-2470/","title":"BOJ 2470"},{"content":" Golang은 구글에서 만들었다. 구글에서 처음 발표되었고, 만든 이유는 C++이 싫어서라고 알려진 듯하다.\n컴파일 언어이지만 속도는 빠르고, 정적 타입 검사를 한다. 라이브러리도 풍부하다고 한다. (이건 공부하면 알겠지\u0026hellip;)\n특징으로 GoRoutine이라는 메커니즘을 제공한다. 서버 개발용으로 설계된 언어기에 멀티코어 환경에서 병렬 처리를 쉽게 구현할 수 있다고 한다. 배우기도 쉽다는데\u0026hellip;\n나는 어떻게 공부하는가 며칠간 Go를 이용해 문제를 풀었었다. 언어에 익숙해지는 과정에서 문제 풀이만큼 좋은 건 없다고 생각해서이다.\n실제 개발은 아니었지만, 며칠간의 문제 풀이에서 배우고 느낀 것을 정리해보자면 다음과 같다.\n Java와 가깝다.\n문제 풀이하면서 가장 크게 생각한 점이다. PS를 하면서 결국 입출력 패키지나 기본 자료구조 패키지들을 하나씩 알게 될수록 Java랑 다를 게 없다고 느껴졌다. Java with pointer 이런 느낌이 아닐까 싶다. 실제 개발을 하면 어떻게 인식이 바뀔지 모르겠다. STL이 없다. 그런데, map이랑 vector가 공짜?\n처음 하는 처지에서 slice 문법과 Heap package는 나한테 너무 가혹했다. 사실 이건 내가 C++ 로 PS를 했었기 때문에 너무 익숙해져 있던 탓이기도 하다. Golang은 기본적으로 문법 자체에서 map, slice(나한테 아직은 slice는 vector다.) 잘 이용하면 좋겠지만, 얼마 배우지도 않고 사용 한거라 매우 어려웠다. 그래도, 문법에서 map을 지원하는 것은 크게 신기했다. package가 많다.\n사실, 문제를 풀면서 크게 이용할 일은 없었다. STL이 없어서 너무 불편했던 나는 package를 찾다가 많은 사람이 Github에 올려놓은 것들을 볼 수 있었고, 사용이 편하다. get을 통해 불러오고 그냥 import 하면 된다.  조금 익숙해졌다고 조심스레 생각이 들어서 본격적인 공부를 할 것 같다. Golang 및 네트워크 프로그래밍 관련된 책이 있어서 책을 정리하며 Golang을 공부할 것 같다.\n","date":"2022-04-11T09:24:17+09:00","permalink":"https://kadrick.github.io/Blog/p/gostudy-1/","title":"GoStudy - 1"},{"content":"글 못쓰는 사람의 우당탕탕 블로그 제목 그대로 나는 글을 못쓴다. 그런데 무슨 블로그냐 싶다.\n이유가 어딨어 그냥 자기만족이지\u0026hellip;\n깨놓고 말하면 공부하고자 하는 의지투합 같은 것이다. CS 공부하면서 배우는 것들을 여기다가 정리할 것이다.\n원래 Notion을 통해 평소 공부하던 것을 기록하고 있었다.\n각 Page에 Tag를 달거나 함수등을 이용해서 정리도 쉬웠고 무엇보다도 디자인도 준수했다.\n그런데 Notion에 적다보니까 너무 난잡해진다.\n블로그 자체는 괜찮은데, 내 일정이나 이런 것들이 주변에 보이니까 심미적으로 좋지 않다.\n그냥 블로그를 하나 완전히 독립시켜버리자 싶어서 알아보다가 괜찮은 테마를 본 것 같아서 적어본다.\n또, commit 도 하나씩 생겨서 (잔디는 항상 안정감을 준다.) 공부하는 느낌을 많이 주기도 했다.\n핑계가 길었다. 아무튼, 첫 번째 포스트는 블로그의 기능이 잘 되는지 테스트 하는 것이라 주저리 주저리 말이 많다.\n이만 줄이자.\n","date":"2022-04-11T00:43:01+09:00","permalink":"https://kadrick.github.io/Blog/p/%EC%B2%AB%EB%B2%88%EC%A7%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8/","title":"첫번째 포스트"}]