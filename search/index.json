[{"content":"BOJ 8982 수족관 1 link\n문제 물이 수조에서 빠질 때, 수조의 모양과 수조 내의 구멍에 따라 수조에 남는 물의 양이 달라진다. 수조의 모양과 수조 내의 구멍 위치가 주어지면 그에 따라 수조에 남아 있는 물의 양을 계산하자.\n풀이 풀이 아이디어는 간단하다. 구멍이 있으면 결국 구멍의 위치가 수면의 위치가 된다. 그래서 모든 구멍을 하나씩 보면서 구멍의 위치에 따라 수면을 정해주고 모두 탐색하였다면, 수면의 위치가 바닥의 위치보다 높다면 계산에 포함한다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  /** * @file 8982.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief map * @version 0.1 * @date 2022-05-04 09:04 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  #define Bottom pair\u0026lt;pair\u0026lt;int, int\u0026gt;, pair\u0026lt;int, int\u0026gt;\u0026gt;  int n, k, tmp, ans; map\u0026lt;Bottom, int\u0026gt; sink; vector\u0026lt;int\u0026gt; hole, up, down, width; int main(void) { fastio; cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; tmp; int size = (n - 2) / 2; up.resize(size, 0); down.resize(size, 0); width.resize(size, 0); for (int i = 0; i \u0026lt; size; i++) { pair\u0026lt;int, int\u0026gt; lpos, rpos; cin \u0026gt;\u0026gt; lpos.first \u0026gt;\u0026gt; lpos.second \u0026gt;\u0026gt; rpos.first \u0026gt;\u0026gt; rpos.second; sink[{lpos, rpos}] = i; down[i] = lpos.second; width[i] = rpos.first - lpos.first; } cin \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; tmp; cin \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; k; i++) { pair\u0026lt;int, int\u0026gt; lpos, rpos; cin \u0026gt;\u0026gt; lpos.first \u0026gt;\u0026gt; lpos.second \u0026gt;\u0026gt; rpos.first \u0026gt;\u0026gt; rpos.second; hole.push_back(sink[{lpos, rpos}]); } // update  for (int i = 0; i \u0026lt; k; i++) { int ceiling = down[hole[i]]; // left  for (int j = hole[i] - 1; j \u0026gt;= 0; j--) { ceiling = min(ceiling, down[j]); up[j] = max(up[j], ceiling); } ceiling = down[hole[i]]; // right  for (int j = hole[i]; j \u0026lt; size; j++) { ceiling = min(ceiling, down[j]); up[j] = max(up[j], ceiling); } } for (int i = 0; i \u0026lt; size; i++) { if (up[i] \u0026lt; down[i]) ans += (down[i] - up[i]) * width[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-05-17T09:38:46+09:00","image":"https://kadrick.github.io/Blog/p/boj-8982/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-8982/","title":"BOJ 8982"},{"content":"BOJ 25048 랜선 연결 link\n문제 $N$ 개의 스위치를 이용해 $M$ 개의 컴퓨터에 인터넷 공급을 한다. 스위치는 $a_i$ 개의 포트가 있고 $b_i$ 의 설치비용이 발생한다. 스위치끼리 사이클이 없고, 남는 포트가 없으며, 최소 비용으로 연결하는게 목적이다. 가능하면 최소비용 출력, 아니면 -1을 출력한다.\n풀이 스위치의 하나의 포트엔 반드시 인터넷이 들어가야 한다. 그러면 남은 포트를 생각해보자. 남은 포트엔 스위치 혹은 컴퓨터가 자리 잡는다. 나눠서 생각해보자.\n 스위치가 연결되면 -\u0026gt; (하나의 포트엔 인터넷, 남은 자리는 스위치 혹은 컴퓨터\u0026hellip;) 컴퓨터가 연결되면 -\u0026gt; 연결할 컴퓨터가 줄어든다.  스위치가 연결되면 같은 문제가 반복된다. 컴퓨터가 연결되면 연결할 컴퓨터의 수가 줄어든다. 여기서 dp로 풀 수 있겠구나 싶었다.\n DP[i] = i개의 컴퓨터를 설치했을 때 최소 비용\n 각 스위치는 인터넷 포트를 제외한 모든 포트에 컴퓨터가 연결된 것이 기저 사례이고, 하나씩 스위치로 바꿔보는 것만 구현하면 문제가 쉽게 풀린다. 스위치를 꼽는 건 부분 문제니까 스위치를 안 꼽으면 부분문제가 없으니 기저 사례가 된다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  /** * @file 25048.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief DP * @version 0.1 * @date 2022-05-03 15:35 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  #define int long long  int n, m; vector\u0026lt;int\u0026gt; netswitch, cost; vector\u0026lt;int\u0026gt; dp; int32_t main(void) { fastio; cin \u0026gt;\u0026gt; n; netswitch.resize(n); cost.resize(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; netswitch[i] \u0026gt;\u0026gt; cost[i]; cin \u0026gt;\u0026gt; m; if (m == 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else { dp.resize(m + 1, LLONG_MAX); // dp[n] = n개의 컴퓨터를 설치할 때 최소 비용  dp[0] = 0; for (int i = 0; i \u0026lt; n; i++) { // 하나는 인터넷 하나는 다른 공유기 나머지 컴퓨터라고 생각  for (int j = m - (netswitch[i] - 2); j \u0026gt;= 1; j--) { // 깔끔한 연결이 아님  if (dp[j] == LLONG_MAX) continue; // 최소 비용 연결  dp[j + (netswitch[i] - 2)] = min(dp[j + (netswitch[i] - 2)], dp[j] + cost[i]); } // 다른 스위치를 꼽지 않고 인터넷과 컴퓨터만 연결되어 있는 경우  if (netswitch[i] - 1 \u0026lt;= m) dp[netswitch[i] - 1] = min(dp[netswitch[i] - 1], cost[i]); } cout \u0026lt;\u0026lt; (dp[m] == LLONG_MAX ? -1 : dp[m]) \u0026lt;\u0026lt; endl; } return 0; }   ","date":"2022-05-17T09:38:30+09:00","image":"https://kadrick.github.io/Blog/p/boj-25048/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-25048/","title":"BOJ 25048"},{"content":"BOJ 25046/25047 사각형 게임 link\n문제 문제가 길다. 사진으로\u0026hellip; 풀이 종진이는 민우가 어떻게 색칠해도 본인이 더 많은 점수를 얻기 위해 색칠을 한다. 그래서 민우가 행을 칠하는 모든 경우에 대해서 종진이의 판단을 구현해주었다. N이 작아서 완전탐색이 가능하다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  /** * @file 25047.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief brute force, implement * @version 0.1 * @date 2022-05-03 14:38 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  #define int long long  int n, ans = LLONG_MIN; // \u0026#34;정수\u0026#34;가 주어진다. vector\u0026lt;int\u0026gt; row; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board; int32_t main(void) { fastio; cin \u0026gt;\u0026gt; n; board.resize(n, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int j = 0; j \u0026lt; n; j++) { cin \u0026gt;\u0026gt; board[i][j]; sum += board[i][j]; } row.push_back(sum); } // 민우가 행을 선택하는 모든 경우  for (int way = 0; way \u0026lt; (1 \u0026lt;\u0026lt; n); way++) { int score = 0; // 우선 모든 선택한 모든 행의 점수더하기  for (int i = 0; i \u0026lt; n; i++) { if (way \u0026amp; (1 \u0026lt;\u0026lt; i)) score += row[i]; } // 열 기준으로 보기 (종진이의 판단)  for (int j = 0; j \u0026lt; n; j++) { int mscore, jscore; mscore = jscore = 0; // 행마다 민우가 칠한 상황에 따라 점수 계산  for (int i = 0; i \u0026lt; n; i++) { if (way \u0026amp; (1 \u0026lt;\u0026lt; i)) { mscore -= board[i][j]; jscore += board[i][j]; } else { mscore += board[i][j]; jscore -= board[i][j]; // 안 칠했을 때는 이만큼의 이득이 있다는 의미임  } } // 결국 종진이가 칠하는게 이득이라면 칠했을 때로 업데이트  if (jscore \u0026gt; 0) score += mscore; } ans = max(ans, score); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-05-17T09:38:01+09:00","image":"https://kadrick.github.io/Blog/p/boj-25046/25047/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-25046/25047/","title":"BOJ 25046/25047"},{"content":"BOJ 25045 비즈마켓 link\n문제 상품들은 만족도를 고객들은 지불하고자 하는 비용을 각각 가지고 있다. 고객 만족도가 (만족도 - 비용) 일때 고객 만족도의 합의 최댓값을 구하자.\n풀이 항상 고객 만족도를 최대로 하는 고객에게 물건을 팔면 된다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  /** * @file 25045.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief sort * @version 0.1 * @date 2022-05-03 13:38 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  #define int long long  int n, m, ans; vector\u0026lt;int\u0026gt; product, company; int32_t main(void) { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; product.resize(n); company.resize(m); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; product[i]; for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; company[i]; sort(product.begin(), product.end(), greater\u0026lt;int\u0026gt;()); sort(company.begin(), company.end()); for (int i = 0; i \u0026lt; min(n, m); i++) ans += max(0ll, product[i] - company[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-05-17T09:36:09+09:00","image":"https://kadrick.github.io/Blog/p/boj-25045/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-25045/","title":"BOJ 25045"},{"content":"BOJ 25044 에어컨 link\n문제 에어컨은 정기적으로 3번 멈춘다. 그런데 에어컨 내장시계가 고장나서 3번 꺼지면 시계가 멈췄다 다시 돌아간다. 현실시간으로 N일째의 에어컨이 꺼지는 시각을 구하는 문제이다.\n풀이 결국 내장시계는 0시에서 15시간 -\u0026gt; 3시간 -\u0026gt; 3시간 -\u0026gt; k분 -\u0026gt; 3시간 루틴으로 하루를 지낸다. 분 계산을 시간 계산으로 하면 소수가 되니까 모든 시간을 분으로 바꿨다. 그리고 N일 때의 범위를 정했다. 내장시계가 아닌 현실 시계가 N일 때는 언제부터이고 (N + 1)일은 언제까지인지를 미리 계산한다. 이후 지정된 루틴을 그대로 수행하면서 N일 때 범위 안에 들어가는 경우를 검사해준다.\n평소와 다르게 printf를 썼는데 format 때문에 그랬다. C++20 에서는 std::format 이라는게 생겼다고 하는데 기회가 되면 사용해보자.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  /** * @file 25044.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief implement * @version 0.1 * @date 2022-05-03 10:23 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  int n, k, idx, cur; int add[5] = {15 * 60, 3 * 60, 3 * 60, 0, 3 * 60}; vector\u0026lt;int\u0026gt; ans; void print(int min) { printf(\u0026#34;%02d:%02d\\n\u0026#34;, min / 60, min % 60); } int main(void) { // fastio;  scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); add[3] = k; int left = 24 * 60 * n; int right = 24 * 60 * (n + 1); // simulate  while (cur + add[idx] \u0026lt; right) { cur += add[idx]; if (left \u0026lt;= cur \u0026amp;\u0026amp; idx \u0026lt; 3) ans.push_back(cur); idx += 1; idx %= 5; } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (auto \u0026amp;\u0026amp;time : ans) print(time - left); return 0; }   ","date":"2022-05-16T11:18:28+09:00","image":"https://kadrick.github.io/Blog/p/boj-25044/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-25044/","title":"BOJ 25044"},{"content":"BOJ 2672 여러 직사각형의 전체 면적 구하기 link\n문제 여러 개의 직사각형이 차지하는 면적을 구하는 문제이다.\n풀이 일단 풀이는 다음과 같다.\n그림도 개떡 같다. 죄송해요.\n우선, 사각형의 왼쪽과 오른쪽을 나눠서 두 개의 라인으로 저장한다. 여기서 왼쪽 라인은 open, 오른쪽 라인은 close로 저장한다. 그리고 모든 라인을 $x$ 좌표를 기준으로 정렬한다. 이후 정렬된 라인들을 차례대로 조사하며 업데이트와 계산을 한다. 코드에서는 입력받으면서 $\\times$ 10을 해주는데, 소수점 처리를 위해서이다. 높이 계산을 위해 mask라는 변수를 만드는데, mask가 open(값이 1 이상)이라면 이전의 라인 중에서 사각형의 왼쪽이 있었다는 의미이다. 즉, 계산에 포함되어야 한다는 것이다.\n계산은 (이전 라인과 현재 라인 사이의 거리) $\\times$ (mask에서 open 되어있는 칸의 개수) 영역의 넓이를 구한다. 그냥 (가로) $\\times$ (세로)다.\n업데이트는 현재 조사하고 있는 라인이 open인가 close인가에 따라 mask에 기록해준다. open이라면 mask에 1을 더하고 close라면 mask에 1을 뺀다.\n글의 설명을 그림에 적용해보면, 아래쪽의 1-4까지 표시된 4개의 라인을 조사하는데, mask와 라인 사이의 거리를 이용해서 (빨간색) 1번 영역에서 3번까지 구하는 것이다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  /** * @file 2672.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief sweeping * @version 0.1 * @date 2022-05-03 09:11 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  typedef struct _RECT { int x, open; // x pos, open or close  int bottom, top; // y pos } Rect; bool comp(const Rect \u0026amp;left, const Rect \u0026amp;right) { if (left.x == right.x) return left.open \u0026lt; right.open; return left.x \u0026lt; right.x; } int n, mask[20001]; vector\u0026lt;Rect\u0026gt; pool; int main(void) { fastio; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { double x, y, w, h; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; x *= 10; y *= 10; w *= 10; h *= 10; Rect left, right; left.open = 1; right.open = -1; left.x = x; right.x = x + w; left.bottom = y; left.top = y + h; right.bottom = y; right.top = y + h; pool.push_back(left); pool.push_back(right); } sort(pool.begin(), pool.end(), comp); long long ans = 0; int before = 0; for (auto \u0026amp;\u0026amp;line : pool) { // calc  int height = 0; for (int i = 0; i \u0026lt; 20001; i++) if (mask[i]) height++; ans += height * (line.x - before); // update  for (int i = line.bottom + 1; i \u0026lt;= line.top; i++) mask[i] += line.open; before = line.x; } if (ans % 100) { cout \u0026lt;\u0026lt; fixed; cout.precision(2); cout \u0026lt;\u0026lt; ans / 100.0 \u0026lt;\u0026lt; endl; } else cout \u0026lt;\u0026lt; ans / 100 \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-05-04T13:06:58+09:00","image":"https://kadrick.github.io/Blog/p/boj-2672/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-2672/","title":"BOJ 2672"},{"content":"BOJ 2470 경로 찾기 link\n문제 하나의 이진 코드에서 시작한다. 1자리의 비트만 바꾸는 연산을 최소로 해서 주어진 최종 이진 코드를 구하면 된다.\n풀이 시작하는 이진 코드에서 한자리씩 바꿔가며 map에 있는지, 더 짧은 거리가 없는지 조사한다. 조건을 만족하면 큐에 넣고 다시 반복한다.\n간단한 BFS다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  /** * @file 2479.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief map * @version 0.1 * @date 2022-04-29 10:38 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  int main(void) { fastio; int n, k, start, end; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; parent(n + 1, -1); vector\u0026lt;string\u0026gt; bucket(n + 1, \u0026#34;\u0026#34;); unordered_map\u0026lt;string, int\u0026gt; table; for (int i = 0; i \u0026lt; n; i++) { string input; cin \u0026gt;\u0026gt; input; table[input] = i + 1; bucket[i + 1] = input; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; queue\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; q; q.push({bucket[start], start}); while (!q.empty()) { auto front = q.front(); q.pop(); if (front.first == bucket[end]) break; for (int i = 0; i \u0026lt; k; i++) { string trans = front.first; trans[i] = (trans[i] == \u0026#39;0\u0026#39; ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;); auto pos = table.find(trans); if (pos == table.end() || parent[(*pos).second] != -1 || (*pos).second == start) continue; parent[(*pos).second] = front.second; q.push({trans, (*pos).second}); } } if (parent[end] == -1) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else { vector\u0026lt;int\u0026gt; ans; ans.push_back(end); end = parent[end]; while (end != -1) { ans.push_back(end); end = parent[end]; } for (int i = ans.size() - 1; i \u0026gt;= 0; i--) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; }   ","date":"2022-05-02T09:05:51+09:00","image":"https://kadrick.github.io/Blog/p/boj-2479/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-2479/","title":"BOJ 2479"},{"content":"BOJ 1162 도로포장 link\n문제 k개의 간선을 무시하고 넘어갈 수 있을 때 도착지까지의 최소비용을 구하는 문제\n풀이 BOJ-10217 과 비슷하게 문제를 풀었다. 10217번은 비용이라는 요소가 추가되었고 이번 문제에서는 비용을 0으로 만드는 횟수가 주어진 것이다.\n결국 출발지점(1번노드)에서 도착지점(N번 노드)까지의 최단거리를 구하는 것과 같다. 도로의 이동시간은 자연수라고 하였으니 다익스트라를 써도 된다. 그렇기에 다익스트라를 통해 구하자. 그런데 그냥 다익스트라를 사용하기에는 비용이 0인 간선의 처리가 부족하다. 어떤 간선의 비용을 0으로 만들면 될까?\n어차피 모르니까 전부 다 계산해보자. 왜? k가 20 이하의 자연수다. 기회가 그렇게 많지 않다고 생각된다. 그럼 어떤 간선을 지날 때 기회를 사용해야 하지? 라는 생각이 들 수 있는데 이 문제는 기회를 어디서 쓰는지 묻고 있지 않다. 어쨌든 최소비용을 구하는 문제다. 어디에보다는 몇 번 사용했는지 기록해서 다음과 같이 dist 배열을 만들자.\n dist[i][j] = 기회를 j번 사용하여 i번에 도달하였을 때 최소비용\n 이러면 결국 정답은 dist[n][0] ~ dist[n][k] 사이의 최솟값이 된다.\n다익스트라 과정 중에 새로운 정점을 큐에 넣을 때, (정점까지의 비용, 정점, 기회 소진 횟수)를 같이 넣어서 구현하면 된다.\n주의할 점은 입력이 양방향 도로이고, 과정 중 int범위를 넘을 수 있다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  /** * @file 1162.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief dijkstra * @version 0.1 * @date 2022-04-13 12:54 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  #define int long long const int INF = LLONG_MAX; int n, m, k, ans = INF; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; graph[10001]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(10001, vector\u0026lt;int\u0026gt;(21, INF)); int32_t main(void) { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; graph[u].push_back({v, c}); graph[v].push_back({u, c}); } for (int i = 0; i \u0026lt; 21; i++) dist[1][i] = true; priority_queue\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; pq; pq.push({0, {1, 0}}); while (pq.size()) { int cost = -pq.top().first; int here = pq.top().second.first; int fix = pq.top().second.second; pq.pop(); if (dist[here][fix] \u0026lt; cost || here == n) continue; for (auto \u0026amp;\u0026amp;there : graph[here]) { // fix  if (fix \u0026lt; k \u0026amp;\u0026amp; dist[there.first][fix + 1] \u0026gt; cost) { dist[there.first][fix + 1] = cost; pq.push({-cost, {there.first, fix + 1}}); } // no fix  if (dist[there.first][fix] \u0026gt; cost + there.second) { dist[there.first][fix] = cost + there.second; pq.push({-(cost + there.second), {there.first, fix}}); } } } for (int i = 0; i \u0026lt; 21; i++) ans = min(ans, dist[n][i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-04-13T13:28:41+09:00","image":"https://kadrick.github.io/Blog/p/boj-1162/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-1162/","title":"BOJ 1162"},{"content":"Go study - syntax - 1 Hello world! 다음은 Hello, world! 이다.\n1 2 3 4 5 6 7 8  // main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) }   main package가 있고, \u0026ldquo;fmt\u0026rdquo; 라는 것을 import 하고, 그곳에 있는 println이라는 method를 이용한다. 자바와 상당이 유사하다고 생각된다. import하는 package는 어떤 게 있을까?\n Google Go Page\n 첫 번째로 위의 사이트의 src directory 밑에 있는 package는 모두 사용 가능 하다. bufio, math, sort 같은 것들을 확인할 수 있다.\n두 번째로 Github 같은 곳에서 package를 가져올 수 있다.\necho 라는 package를 사용하는 예제이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import ( \u0026#34;github.com/labstack/echo/v4\u0026#34; \u0026#34;github.com/labstack/echo/v4/middleware\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // Echo instance  e := echo.New() // Middleware  e.Use(middleware.Logger()) e.Use(middleware.Recover()) // Routes  e.GET(\u0026#34;/\u0026#34;, hello) // Start server  e.Logger.Fatal(e.Start(\u0026#34;:1323\u0026#34;)) } // Handler func hello(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;Hello, World!\u0026#34;) }   doc의 설명을 읽어보면 install을 하고 다음과 같이 import에 명시해주기만 하면 된다.\n1 2  // go get github.com/labstack/echo/{version} go get github.com/labstack/echo/v4   Go의 버전이 높다면 get 커맨드로 install이 되지 않는다. install을 이용하여야 한다.\n1  go install github.com/labstack/echo/v4@latest   이런 식으로 사용하면 된다.\n 다시 Hello, world!로 돌아가면 ;(세미콜론)도 없는 것을 확인할 수 있다. 컴파일 시에 문장 끝에 자동으로 ;을 삽입한다. 명시해도 상관없는 것으로 알고 있는데, vscode 설치 후 저장 시에 어차피 붙어있는 ;도 없애기에 앞으로는 ;없이 코드를 작성할 것 같다.\n 주석은 C 처럼 /* */ 사이에 작성해도 되고, //을 사용해도 된다.\n Go 에서는 {}(중괄호)의 위치를 따진다. 함수 선언, 제어문 뒤에 오는 여는 중괄호는 반드시 줄 바꿈을 하지 않고 바로 뒤에 작성해야 한다. 말로 하면 어렵다. 예시를 보면 바로 이해할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // main.go package main import \u0026#34;fmt\u0026#34; /* // 이런 형식이 불가능하다. func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) } */ func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) }    Variables, 변수 Go 에서의 변수의 사용과 자료형에 대해서 알아보자.\nDeclaration, 변수를 사용해보자. 기본적인 변수 선언은 키워드 var, const 을 통해서 진행한다. \u0026ldquo;\u0026lt;var | const\u0026gt; \u0026lt;변수 이름\u0026gt; \u0026lt;자료형\u0026gt;\u0026rdquo; 형식으로 사용한다. var은 일반적인 변수, cosnt는 상수를 의미한다.\n선언과 정의를 동시에 하기 위해서 \u0026ldquo;:=\u0026rdquo; 을 사용할 수 있는데 전역으로 사용은 불가능하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import \u0026#34;fmt\u0026#34; const num3 int = 4 func main() { // 변수 선언시 초기화 하지 않으면 자동으로 자료형에 맞는 기본값으로 초기화  // int: 0, bool: flase 로 초기화 된다. string은 빈문자열 이런 식으로... \tvar num1 int var num2 int = 1 num1 = 2 fmt.Printf(\u0026#34;%d %d\u0026#34;, num1+num2, num3) }   Data Type, 변수의 그릇 Go의 자료형은 document를 확인하면 알 수 있다. 영어라서 어질어질하지만 요약하면 아래의 표가 된다.\n   type description byte     bool true, false 1   uint8 음수를 제외한 1byte 정수 1   uint16 음수를 제외한 2byte 정수 2   uint32 음수를 제외한 4byte 정수 4   uint64 음수를 제외한 8byte 정수 8   int8 1byte 정수 1   int16 2byte 정수 2   int32 4byte 정수 4   int64 8byte 정수 8   float32 4byte 실수 4   float64 8byte 실수 8   complex64 float32 실수부와 허수부 8   complex128 flaot64 실수부와 허수부 8   int, uint 아키텍쳐에 따라 크기가 다름 4, 8   string (배열을 가리키는 포인터, 배열의 길이) 8, 16   byte alias for uint8 1   rune alias for int32 4   uintptr 포인터 값 저장을 위함 4    자료형에 관한 공부는 다음을 참고해도 좋다. Go Data Type\ndoc이나 다른 자료들이 설명하는 자료형에는 위의 설명 외에도 slice, map 등이 있고, type을 묶는(표현이 맞는지 모르겠다.) struct, method 집합인 interface와 같이 더 많은 기능이 있다. 지금 표에 있는 것이 기본적이기도 하지만, 전부는 아니라는 소리다. 이후에 하나씩 따로 공부해야 할 만큼 큰 부분들이라고 생각해서 지금은 적지 않았다.\nType conversion, 형변환\u0026hellip;? Go 에서는 암시적 형변환이 없다. C++, Java 같은 언어들은 암시적 형변환을 지원하지만, Go 언어에서는 명시적 형변환을 해야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Go program to find the // average of numbers package main import \u0026#34;fmt\u0026#34; func main() { // taking the required \t// data into variables \tvar totalsum int = 846 var number int = 19 var avg float32 // explicit type conversion \tavg = float32(totalsum) / float32(number) // Displaying the result \tfmt.Printf(\u0026#34;Average = %f\\n\u0026#34;, avg) }   Type Conversion in geeksforgeeks\n마무리 간단하게 정리해보았다. 기본적인 hello, world 분석이랑 변수 사용, 자료형에 대해서 알아보았다. 아마 다음 글은 제어문과 관련된 문법일 것 같다. 정리하면서 다시 공부하니까 복습 효과가 잘 나오는 것 같다. 그럼 이만 줄인다.\n","date":"2022-04-13T09:10:49+09:00","permalink":"https://kadrick.github.io/Blog/p/gostudy-2/","title":"GoStudy - 2"},{"content":"BOJ 21924 도시 건설 link\n문제 요약하면 (그래프에 속하는 모든 간선의 가중치의 합 - MST에 속하는 간선의 가중치의 합)을 구하는 문제다.\n풀이 MST를 구하는 문제와 다를 것이 없다. Kruskal 알고리즘을 사용해서 문제를 풀었다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  /** * @file 21924.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief MST * @version 0.1 * @date 2022-04-12 12:55 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  int n, m; long long total; vector\u0026lt;int\u0026gt; parent; vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; edges; int find(int root) { if (root == parent[root]) return root; return parent[root] = find(parent[root]); } bool merge(int u, int v) { u = find(u); v = find(v); if (u == v) return false; if (u \u0026gt; v) swap(u, v); parent[v] = u; return true; } int main(void) { fastio; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; parent.resize(n + 1); for (int i = 0; i \u0026lt;= n; i++) parent[i] = i; for (int i = 0; i \u0026lt; m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; total += c; edges.push_back({c, {u, v}}); } sort(edges.begin(), edges.end()); int cnt = 0; long long mst = 0; for (int i = 0; i \u0026lt; m; i++) { if (merge(edges[i].second.first, edges[i].second.second)) { cnt++; mst += edges[i].first; } if (cnt == n - 1) break; } if (cnt == n - 1) cout \u0026lt;\u0026lt; total - mst \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; }   ","date":"2022-04-12T13:07:11+09:00","image":"https://kadrick.github.io/Blog/p/boj-21924/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-21924/","title":"BOJ 21924"},{"content":"BOJ 2470 두 용액 link\n문제 요약하면 주어진 배열에서 두 수를 더했을 때 0에 가장 가까운 두 수를 구하는 것이다.\n풀이 Two pointers 알고리즘을 알고 있다면, 쉽게 풀 수 있다.\n풀이는 다음과 같다.\nleft가 배열의 처음 / right가 배열의 마지막을 가르치고 있다.\n 우선 들어온 용액을 오름차순 정렬한다. left가 가리키는 수와 right가 가리키는 수를 더한다.\n2-1. 더한 결과가 현재 0과 가까운 수보다 더 0에 가까우면 업데이트한다. 결과가 0이라면 그대로 종료해도 된다.\n2-2. 더한 결과가 0보다 작다면 left를 +1 해준다. 이후 다시 2번부터 진행한다.\n2-3. 더한 결과가 0보다 크다면 right를 -1 해준다. 이후 다시 2번부터 진행한다.  반복하다가 left \u0026lt; right 를 만족하지 못하면 종료한다.\n두 수의 합에 따라 용액을 더 넣거나 빼는 것으로 생각하면 쉽다.\n소스코드  C++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  /** * @file 2470.cpp * @author Kadrick (kbk2581553@gmail.com) * @brief two pointers * @version 0.1 * @date 2022-04-11 20:53 * * @copyright Copyright (c) 2022 * */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define fastio \\ ios::sync_with_stdio(false); \\ cin.tie(0); #define endl \u0026#39;\\n\u0026#39;  void solve(int n, vector\u0026lt;int\u0026gt; \u0026amp;water) { pair\u0026lt;int, int\u0026gt; ans; int left = 0, right = n - 1; ans.first = ans.second = 1e9; while (left \u0026lt; right) { if (abs(water[left] + water[right]) \u0026lt;= abs(ans.first + ans.second)) { ans.first = water[left]; ans.second = water[right]; if (ans.first + ans.second == 0) break; } if (water[left] + water[right] \u0026lt; 0) left++; else right--; } cout \u0026lt;\u0026lt; ans.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans.second \u0026lt;\u0026lt; endl; } int main(void) { fastio; int n; vector\u0026lt;int\u0026gt; water; cin \u0026gt;\u0026gt; n; water.resize(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; water[i]; sort(water.begin(), water.end()); solve(n, water); return 0; }   ","date":"2022-04-11T21:06:22+09:00","image":"https://kadrick.github.io/Blog/p/boj-2470/boj-banner_hua8dbec156adc816fe5043c41cdb6daaf_110403_120x120_fill_box_smart1_2.png","permalink":"https://kadrick.github.io/Blog/p/boj-2470/","title":"BOJ 2470"},{"content":" Golang은 구글에서 만들었다. 구글에서 처음 발표되었고, 만든 이유는 C++이 싫어서라고 알려진 듯하다.\n컴파일 언어이지만 속도는 빠르고, 정적 타입 검사를 한다. 라이브러리도 풍부하다고 한다. (이건 공부하면 알겠지\u0026hellip;)\n특징으로 GoRoutine이라는 메커니즘을 제공한다. 서버 개발용으로 설계된 언어기에 멀티코어 환경에서 병렬 처리를 쉽게 구현할 수 있다고 한다. 배우기도 쉽다는데\u0026hellip;\n나는 어떻게 공부하는가 며칠간 Go를 이용해 문제를 풀었었다. 언어에 익숙해지는 과정에서 문제 풀이만큼 좋은 건 없다고 생각해서이다.\n실제 개발은 아니었지만, 며칠간의 문제 풀이에서 배우고 느낀 것을 정리해보자면 다음과 같다.\n Java와 가깝다.\n문제 풀이하면서 가장 크게 생각한 점이다. PS를 하면서 결국 입출력 패키지나 기본 자료구조 패키지들을 하나씩 알게 될수록 Java랑 다를 게 없다고 느껴졌다. Java with pointer 이런 느낌이 아닐까 싶다. 실제 개발을 하면 어떻게 인식이 바뀔지 모르겠다. STL이 없다. 그런데, map이랑 vector가 공짜?\n처음 하는 처지에서 slice 문법과 Heap package는 나한테 너무 가혹했다. 사실 이건 내가 C++ 로 PS를 했었기 때문에 너무 익숙해져 있던 탓이기도 하다. Golang은 기본적으로 문법 자체에서 map, slice(나한테 아직은 slice는 vector다.) 잘 이용하면 좋겠지만, 얼마 배우지도 않고 사용 한거라 매우 어려웠다. 그래도, 문법에서 map을 지원하는 것은 크게 신기했다. package가 많다.\n사실, 문제를 풀면서 크게 이용할 일은 없었다. STL이 없어서 너무 불편했던 나는 package를 찾다가 많은 사람이 Github에 올려놓은 것들을 볼 수 있었고, 사용이 편하다. get을 통해 불러오고 그냥 import 하면 된다.  조금 익숙해졌다고 조심스레 생각이 들어서 본격적인 공부를 할 것 같다. Golang 및 네트워크 프로그래밍 관련된 책이 있어서 책을 정리하며 Golang을 공부할 것 같다.\n","date":"2022-04-11T09:24:17+09:00","permalink":"https://kadrick.github.io/Blog/p/gostudy-1/","title":"GoStudy - 1"},{"content":"글 못쓰는 사람의 우당탕탕 블로그 제목 그대로 나는 글을 못쓴다. 그런데 무슨 블로그냐 싶다.\n이유가 어딨어 그냥 자기만족이지\u0026hellip;\n깨놓고 말하면 공부하고자 하는 의지투합 같은 것이다. CS 공부하면서 배우는 것들을 여기다가 정리할 것이다.\n원래 Notion을 통해 평소 공부하던 것을 기록하고 있었다.\n각 Page에 Tag를 달거나 함수등을 이용해서 정리도 쉬웠고 무엇보다도 디자인도 준수했다.\n그런데 Notion에 적다보니까 너무 난잡해진다.\n블로그 자체는 괜찮은데, 내 일정이나 이런 것들이 주변에 보이니까 심미적으로 좋지 않다.\n그냥 블로그를 하나 완전히 독립시켜버리자 싶어서 알아보다가 괜찮은 테마를 본 것 같아서 적어본다.\n또, commit 도 하나씩 생겨서 (잔디는 항상 안정감을 준다.) 공부하는 느낌을 많이 주기도 했다.\n핑계가 길었다. 아무튼, 첫 번째 포스트는 블로그의 기능이 잘 되는지 테스트 하는 것이라 주저리 주저리 말이 많다.\n이만 줄이자.\n","date":"2022-04-11T00:43:01+09:00","permalink":"https://kadrick.github.io/Blog/p/%EC%B2%AB%EB%B2%88%EC%A7%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8/","title":"첫번째 포스트"}]